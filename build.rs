use std::io::Write;

const XDR_X_PATH: &str = r#"./xdr"#;
const XDR_RS_PATH: &str = r#"/xdr.rs"#;
fn main() {
    println!("cargo:rerun-if-env-changed=OUT_DIR");
    println!("cargo:rerun-if-changed={}", XDR_X_PATH);
    let out_dir: &str = &std::env::var("OUT_DIR").unwrap();
    //println!("cargo:rerun-if-changed={}", out_dir);
    let mut xdr_rs = String::from(r#"//auto generated by build.rs, don't modify this"#);

    for entry in
        std::fs::read_dir(XDR_X_PATH).expect(&format!("directory '{}' doesn't exist", XDR_X_PATH))
    {
        match entry {
            Ok(entry) => {
                if !entry
                    .metadata()
                    .expect("error identifying file type")
                    .is_file()
                {
                    continue;
                } else {
                    let path = entry.path();
                    let path = path.to_str().unwrap();
                    xdrgen::compile(path).expect(&format!("xdrgen {} failed", path));
                    xdr_rs.push_str(&format!(
                        r##"include!(concat!(r#"{}"#, "/{}_xdr.rs"));"##,
                        out_dir,
                        entry
                            .file_name()
                            .to_str()
                            .unwrap()
                            .chars()
                            .take_while(|x| *x != '.')
                            .collect::<String>()
                    ));
                }
            }
            Err(e) => {
                panic!(
                    "error iterating over file in '{}':\n{}",
                    XDR_X_PATH,
                    e.to_string()
                );
            }
        }
    }
    let mut mod_path = out_dir.to_string();
    mod_path.push_str(XDR_RS_PATH);
    let mut file =
        std::fs::File::create(&mod_path).expect(&format!("creating '{}' failed", mod_path));
    file.write_all(xdr_rs.as_bytes())
        .expect(&format!("writing to '{}' failed", XDR_RS_PATH));
}
