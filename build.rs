use std::io::{Read, Write};

const XDR_X_PATH: &str = r#"./xdr"#;
const XDR_RS_PATH: &str = r#"/xdr.rs"#;
fn main() {
    println!("cargo:rerun-if-env-changed=OUT_DIR");
    println!("cargo:rerun-if-changed={}", XDR_X_PATH);
    let out_dir: &str = &std::env::var("OUT_DIR").unwrap();
    //println!("cargo:rerun-if-changed={}", out_dir);
    let mut xdr_rs = String::from(r#"//auto generated by build.rs, don't modify this"#);

    for entry in
        std::fs::read_dir(XDR_X_PATH).expect(&format!("directory '{}' doesn't exist", XDR_X_PATH))
    {
        match entry {
            Ok(entry) => {
                if !entry
                    .metadata()
                    .expect("error getting file metadata")
                    .is_file()
                {
                    continue;
                } else {
                    let path = entry.path();
                    let in_file = entry.file_name();
                    let in_file = in_file.to_str().unwrap();
                    let mut out_file = in_file
                        .chars()
                        .take_while(|x| *x != '.')
                        .collect::<String>();
                    out_file.push_str("_xdr.rs");
                    let mut buf = String::new();
                    std::fs::File::open(path)
                        .expect(&format!("error opening file '{}'", in_file))
                        .read_to_string(&mut buf)
                        .expect(&format!("error reading file '{}'", in_file));
                    std::fs::write(
                        std::path::Path::new(std::env::var("OUT_DIR").unwrap().as_str())
                            .join(out_file),
                        fastxdr::Generator::default()
                            .generate(buf)
                            .expect(&format!("error parsing file '{}'", in_file)),
                    )
                    .unwrap();
                    xdr_rs.push_str(&format!(
                        r##"include!(concat!(r#"{}"#, "/{}_xdr.rs"));"##,
                        out_dir,
                        entry
                            .file_name()
                            .to_str()
                            .unwrap()
                            .chars()
                            .take_while(|x| *x != '.')
                            .collect::<String>()
                    ));
                }
            }
            Err(e) => {
                panic!(
                    "error iterating over file in '{}':\n{}",
                    XDR_X_PATH,
                    e.to_string()
                );
            }
        }
    }
    let mut mod_path = out_dir.to_string();
    mod_path.push_str(XDR_RS_PATH);
    let mut file =
        std::fs::File::create(&mod_path).expect(&format!("creating '{}' failed", mod_path));
    file.write_all(xdr_rs.as_bytes())
        .expect(&format!("writing to '{}' failed", XDR_RS_PATH));
}
